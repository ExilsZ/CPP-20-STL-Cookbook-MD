# 第 8 章实用工具类

C++标准库包括为特定任务设计的各种工具类。有些是常见的，读者们可能在这本书的其他示例中见过很多这样的类。

本章在以下主题中介绍了一些通用的工具，包括时间测量、泛型类型、智能指针等：

- std::optional 管理可选值
- std::any 保证类型安全
- std::variant 存储不同的类型
- std::chrono 的时间事件
- 对可变元组使用折叠表达式
- std::unique_ptr 管理已分配的内存
- std::shared_ptr 的共享对象
- 对共享对象使用弱指针
- 共享管理对象的成员
- 比较随机数引擎
- 比较随机数分布发生器

## 8.1.相关准备

本章所有的例子和源代码都可以在本书的 GitHub 库中找到，网址是<https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap08>。

## 8.2.std::optional 管理可选值

C++17 引入的 std::optional 类保存了一个可选值。

假设有一个函数，它可能返回值，也可能不返回值------例如，一个函数检查一个数字是否是质数，但若存在第一个因数，则返回第一个因数。此函数应返回值或 bool 状态。可以创建一个同时包含值和状态的结构体：

```cpp
struct factor_t {
    bool is_prime;
    long factor;
};
factor_t factor(long n) {
    factor_t r{};
    for(long i = 2; i <= n / 2; ++i) {
        if (n % i == 0) {
            r.is_prime = false;
            r.factor = i;
            return r;
        }
    }
    r.is_prime = true;
    return r;
}
```

这是一个笨拙的解决方案，但它是有效的，而且很常见。

optional 类可以让这个任务变得简单：

```cpp
optional<long> factor(long n) {
    for (long i = 2; i <= n / 2; ++i) {
        if (n % i == 0) return {i};
    }
    return {};
}
```

使用 optional，可以返回值或非值。

我们可以这样使用：

```cpp
long a{ 42 };
long b{ 73 };
auto x = factor(a);
auto y = factor(b);
if(x) cout << format("lowest factor of {} is {}\n", a, *x);
else cout << format("{} is prime\n", a);
if(y) cout << format("lowest factor of {} is {}\n", b, *y);
else cout << format("{} is prime\n", b);
```

输出为：

```text
lowest factor of 42 is 2 73 is prime
```

### How to do it

这个示例中，来看看如何使用 optional 类的例子：

- optional 类非常简单。使用标准模板表示法构造一个 optional:

    ```cpp
    optional<int> a{ 42 };
    cout << *a << '\n';
    ```

    使用指针的解引用操作符访问可选对象的值。

    输出为：

    ```text
    42
    ```

- 使用 bool 操作符来测试 optional 是否有值：

    ```cpp
    if(a) cout << *a << '\n';
    else cout << "no value\n";
    ```

    若构造 a 时不带值：

    ```cpp
    optional<int> a{};
    ```

    输出将输出 else 的内容：

    ```shell
    no value
    ```

- 我们可以通过声明类型别名来进一步简化：

    ```cpp
    using oint = std::optional<int>;
    oint a{ 42 };
    oint b{ 73 };
    ```

- 若想对 oint 对象进行操作，可以对操作符进行重载：

    ```cpp
    oint operator+(const oint& a, const oint& b) {
        if(a && b) return *a + *b;
        else return {};
    }
    oint operator+(const oint& a, const int b) {
        if(a) return *a + b;
        else return {};
    }
    ```

    现在，可以直接操作 oint 对象：

    ```cpp
    auto sum{ a + b };
    if(sum) {
        cout << format("{} + {} = {}\n", *a, *b, *sum);
    } else {
        cout << "NAN\n";
    }
    ```

    输出为：

    ```cpp
    42 + 73 = 115
    ```

- 假设用默认构造函数声明 b:

    ```cpp
    oint b{};
    ```

    现在，可得到 else 分支的输出：

    ```cpp
    NAN
    ```

### How it works

std::optional 类是为了简单而创建的，其为许多常用函数提供操作符重载。还包括成员函数，可提供更进一步的灵活性。

optional 类提供了一个操作符 bool 重载，用于确定对象是否有值：

```cpp
optional<int> n{ 42 };
if(n) ... // has a value
```

或者，可以使用 has_value() 成员函数：

```cpp
if(n.has_value()) ... // has a value
```

要访问该值，可以使用解引用操作符的重载：

```cpp
x = *n; // * retruns the value
```

或者，可以使用 value() 成员函数：

```cpp
x = n.value(); // * retruns the value
```

reset() 成员函数可以销毁该值，并重置可选对象的状态：

```cpp
n.reset(); // no longer has a value
```

### There's more

optional 类通过 value() 方法提供异常支持：

```cpp
b.reset();
try {
    cout << b.value() << '\n';
} catch(const std::bad_optional_access& e) {
    cout << format("b.value(): {}\n", e.what());
}
```

输出为：

```text
b.value(): bad optional access
```

``` tcolorbox
只有 value() 方法会抛出异常。对于无效值，解引用操作符的行为未定义。
```

## 8.3.std::any 保证类型安全

C++17 中引入了 std::any 类，可为任何类型的单个对象提供了类型安全的容器。

例如，这是一个默认构造的 any 对象：

```cpp
any x{};
```

该对象无值，可以使用 has_value() 方法进行测试：

```cpp
if(x.has_value()) cout << "have value\n";
else cout << "no value\n";
```

输出为：

```text
no value
```

我们使用赋值操作符为 any 对象赋值：

```cpp
x = 42;
```

现在，any 对象有一个值和一个类型：

```cpp
if(x.has_value()) {
    cout << format("x has type: {}\n", x.type().name());
    cout << format("x has value: {}\n", any_cast<int>(x));
} else {
    cout << "no value\n";
}
```

输出为：

```text
x has type: i x has value: 42
```

type() 方法返回一个 type_info 对象，type_info::name() 方法返回 C-string 类型的实现定义的名称。在本例中，GCC 中 i 表示 int。

使用 `any_cast<type>()` 非成员函数强制转换值进行使用。

可以用不同类型的不同值重新赋值：

```cpp
x = "abc"s;
cout << format("x is type {} with value {}\n",
    x.type().name(), any_cast<string>(x))
```

输出为：

```text
x is type NSt7__cxx1112basic_string... with value abc
```

用 GCC 缩写了这个长类型名，相同的对象，曾经持有 int，现在包含一个 STL 字符串对象。

any 类的主要是创建一个多态函数，来看看这个示例。

### How to do it

这个示例中，将使用 any 类构建一个多态函数，可以在其参数中接受不同类型对象的函数：

- 多态函数可以接受任意对象，并打印其类型和值：

    ```cpp
    void p_any(const any& a) {
        if (!a.has_value()) {
            cout << "None.\n";
        } else if (a.type() == typeid(int)) {
            cout << format("int: {}\n", any_cast<int>(a));
        } else if (a.type() == typeid(string)) {
            cout << format("string: "{}"\n",
            any_cast<const string&>(a));
        } else if (a.type() == typeid(list<int>)) {
            cout << "list<int>: ";
            for(auto& i : any_cast<const list<int>&>(a))
                cout << format("{} ", i);
            cout << '\n';
        } else {
            cout << format("something else: {}\n",
            a.type().name());
        }
    }
    ```

    p_any() 函数首先测试对象是否有值，针对各种类型测试 type() 方法，并对每种类型采取适当的操作。

    在 any 类之前，必须为这个函数编写四种不同的特化，并且不能简单地处理默认的情况。

- 在 main() 使用这个函数：

    ```cpp
    p_any({});
    p_any(47);
    p_any("abc"s);
    p_any(any(list{ 1, 2, 3 }));
    p_any(any(vector{ 1, 2, 3 }));
    ```

    输出为：

    ```text
    one. int: 47 string: "abc" list<int>: 1 2 3
    something else: St6vectorIiSaIiEE
    ```

我们的多态函数用最少的代码处理了各种类型的变量。

### How it works

any 复制构造函数和赋值操作符，可以直接初始化来生成目标对象的非 const 副本作为包含对象，包含的对象类型可以作为 typeid 单独存储。

初始化后，any 对象有以下方法：

- emplace() 替换包含的对象，在适当的位置构造新对象。

- reset() 替换包含的对象，在适当的位置构造新对象。

- has_value() 若有包含对象，则返回 true。

- type() 返回 typeid 对象，表示所包含对象的类型。

- operator=() 用复制或移动操作替换包含的对象。

`any` 类还支持以下非成员函数：

- `any_cast<T>()`，模板函数，提供对包含对象的类型安全访问。

    `any_cast<T>()` 函数返回包含对象的副本，可以使用 `any_cast<T&>()` 来返回引用。

- `std::swap()` 专门处理 `std::swap` 算法。

若用错误的类型强制转换 `any` 对象，则会抛出一个 `bad_any_cast` 异常：

```cpp
try {
    cout << any_cast<int>(x) << '\n';
} catch(std::bad_any_cast& e) {
    cout << format("any: {}\n", e.what());
}
```

输出为：

```text
any: bad any_cast
```

## 8.4.std::variant 存储不同的类型

C++17 中引入的 std::variant 类可以保存不同的值，每次一个，其中每个值必须适合相同的分配内存空间。对于保存可供在单个上下文中使用的替代类型非常有用。

### 与 union 的区别

variant 类是一个带标记的联合，其与原始 union 结构的不同之处在于，一次只能有一种类型起作用。

原始 union 类型继承自 C，是一种结构，在这种结构中，相同的数据可以作为不同的类型访问。例如：

```cpp
union ipv4 {
    struct {
        uint8_t a; uint8_t b; uint8_t c; uint8_t d;
    }quad;
    uint32_t int32;
} addr;
addr.int32 = 0x2A05A8C0;
cout << format("ip addr dotted quad: {}.{}.{}.{}\n",
    addr.quad.a, addr.quad.b, addr.quad.c, addr.quad.d);
cout << format("ip addr int32 (LE): {:08X}\n", addr.int32);
```

输出为：

```text
ip addr dotted quad: 192.168.5.42 ip addr int32 (LE):
2A05A8C0
```

这个例子中，union 有两个成员，类型是 struct 和 uint32_t，其中 struct 有四个 uint8_t 成员。这为我们提供了相同 32 位内存空间的两种不同视角，可以将相同的 ipv4 地址视为一个 32 位无符号整数 (Little
Endian 或 LE) 或四个 8 位无符号整数。这提供了在系统级别的位多态。

variant 不是这样的。variant 类是一个带标记的 union，其中每个数据都带有其类型的标记。若将一个值存储为 uint32_t，只能以 uint32_t 的形式访问。这使得 variant 类型安全，但并不是 union 的替代品。

### How to do it

示例中，将展示 std::variant 的使用方式。

- 我们将从一个简单的类开始，先来保存一个 Animal:

    ```cpp
    class Animal {
        string_view _name{};
        string_view _sound{};
        Animal();
    public:
        Animal(string_view n, string_view s)
        : _name{ n }, _sound{ s } {}
        void speak() const {
            cout << format("{} says {}\n", _name, _sound);
        }
        void sound(string_view s) {
            _sound = s;
        }
    }
    ```

    动物的名字和动物发出的声音被传递到构造函数中。

- 不同的物种类继承自 Animal:

    ```cpp
    class Cat : public Animal {
        public:
        Cat(string_view n) : Animal(n, "meow") {}
    };
    class Dog : public Animal {
        public:
        Dog(string_view n) : Animal(n, "arf!") {}
    };
    class Wookie : public Animal {
        public:
        Wookie(string_view n) : Animal(n, "grrraarrgghh!") {}
    };
    ```

    这些类中的每一个都通过调用父构造函数，来为其物种类设置声音。

- 现在，可以在别名中定义变量类型：

    ```cpp
    using v_animal = std::variant<Cat, Dog, Wookie>;
    ```

    这个变体可以容纳任何类型，猫，狗或伍基。

- 在 main() 中，使用 v_animal 别名作为类型创建了一个列表：

    ```cpp
    int main() {
        list<v_animal> pets{
            Cat{"Hobbes"}, Dog{"Fido"}, Cat{"Max"},
            Wookie{"Chewie"}
        };
        ...
    ```

    列表中的每个元素都是变量定义中包含的类型。

- variant 类提供了几种访问元素的不同方法，先来看看 visit()。

    visit() 调用带有当前包含在变体中的对象的函子。首先，定义一个接受宠物的函子：

    ```cpp
    struct animal_speaks {
        void operator()(const Dog& d) const { d.speak(); }
        void operator()(const Cat& c) const { c.speak(); }
        void operator()(const Wookie& w) const {
            w.speak(); }
    };
    ```

    这是一个简单的函子类，每个 Animal 子类都有重载。使用 visit() 调用它，并使用列表的每个元素：

    ```cpp
    for (const v_animal& a : pets) {
        visit(animal_speaks{}, a);
    }
    ```

    会得到这样的输出：

    ```shell
    Hobbes says meow Fido says arf! Max says meow Chewie
    says grrraarrgghh!
    ```

- variant 类还提供了一个 index() 方法：

    ```cpp
    for(const v_animal &a : pets) {
        auto idx{ a.index() };
        if(idx == 0) get<Cat>(a).speak();
        if(idx == 1) get<Dog>(a).speak();
        if(idx == 2) get<Wookie>(a).speak();
    }
    ```

    可以得到这样的输出：

    ```shell
    Hobbes says meow Fido says arf! Max says meow Chewie
    says grrraarrgghh!
    ```

    每个变量对象都根据模板参数中声明类型的顺序建立索引。av_animal 类型定义为 std::variant<Cat,
    Dog, Wookie>，这些类型的索引顺序为 0 - 2。

- `get_if<T>()` 函数的作用是：根据类型测试给定元素：

    ```cpp
    for (const v_animal& a : pets) {
        if(const auto c{ get_if<Cat>(&a) }; c) {
            c->speak();
        } else if(const auto d{ get_if<Dog>(&a) }; d) {
            d->speak();
        } else if(const auto w{ get_if<Wookie>(&a) }; w) {
            w->speak();
        }
    }
    ```

    输出为：

    ```text
    Hobbes says meow Fido says arf! Max says meow Chewie
    says grrraarrgghh!
    ```

    `get_if<T>()` 函数的作用是：若元素类型与 T 匹配，则返回一个指针;否则，返回 nullptr。

- 最后，`hold_alternative<T>()` 函数返回 true 或 false。可以使用 this 来测试一个类型是否对应一个元素，而不返回该元素：

    ```cpp
    size_t n_cats{}, n_dogs{}, n_wookies{};
    for(const v_animal& a : pets) {
        if(holds_alternative<Cat>(a)) ++n_cats;
        if(holds_alternative<Dog>(a)) ++n_dogs;
        if(holds_alternative<Wookie>(a)) ++n_wookies;
    }
    cout << format("there are {} cat(s), "
                    "{} dog(s), "
                    "and {} wookie(s)\n",
                    n_cats, n_dogs, n_wookies);
    ```

    输出为：

    ```text
    there are 2 cat(s), 1 dog(s), and 1 wookie(s)
    ```

### How it works

std::variant 类是一个单对象容器。variant<X, Y, Z>实例的类型，必须是 X,
Y 或 Z 对象类型的其中之一，并可以同时保存当前对象的值和类型。

index() 方法告诉我们当前对象的类型：

```cpp
if(v.index() == 0) // if variant is type X
```

`holds_alternative<T>()` 非成员函数如果 T 是当前对象的类型，则返回 true:

```cpp
if(holds_alternative<X>(v)) // if current variant obj is type X
```

可以使用 get() 非成员函数检索当前对象：

```cpp
auto o{ get<X>(v) }; // current variant obj must be type X
```

可以将类型和检索测试与 get_if() 非成员函数结合起来：

```cpp
auto* p{ get_if<X>(v) }; // nullptr if current obj not type X
```

visit() 非成员函数使用一个可调用对象，将当前变量对象作为其唯一形参：

```cpp
visit(f, v); // calls f(v) with current variant obj
```

visit() 函数是在不测试对象类型的情况下，检索对象的唯一方法。结合一个可以处理每种类型的函子，就非常灵活了：

```cpp
struct animal_speaks {
    void operator()(const Dog& d) const { d.speak(); }
    void operator()(const Cat& c) const { c.speak(); }
    void operator()(const Wookie& v) const { v.speak(); }
};
main() {
    for (const v_animal& a : pets) {
        visit(animal_speaks{}, a);
    }
}
```

输出为：

```text
Hobbes says meow Fido says arf! Max says meow Chewie says
grrraarrgghh!
```

## 8.5.std::chrono 的时间事件

std::chrono 库提供了用于测量、报告时间和间隔的工具。

这些类和函数中的许多都是在 C++11 中引入的，但在 C++20 中已经有了重大的变化和更新。在撰写本文时，许多更新还没有在我测试的系统上实现。

本示例使用 chrono 库，为事件进行计时。

### How to do it

system_clock 类用于报告当前日期和时间。steady_clock 和 high_resolution_clock 类用于计时事件。让我们来看看这些时钟间的区别：

- 因为这些名字可能又长又不方便，在整个示例中使用一些类型别名：

    ```cpp
    using std::chrono::system_clock;
    using std::chrono::steady_clock;
    using std::chrono::high_resolution_clock;
    using std::chrono::duration;
    using seconds = duration<double>;
    using milliseconds = duration<double, std::milli>;
    using microseconds = duration<double, std::micro>;
    using fps24 = duration<unsigned long, std::ratio<1, 24>>;
    ```

    duration 类表示两个时间点之间的间隔。这些别名便于使用不同的间隔。

- 可以使用 system_clock 类来获取当前时间和日期：

    ```cpp
    auto t = system_clock::now();
    cout << format("system_clock::now is {:%F %T}\n", t);
    ```

    system_clock::now() 函数的作用是：返回一个 time_point 对象。`<chrono>` 库包含了 time_point 的 format() 特化，该特化使用 strftime() 格式说明符。

    输出为：

    ```text
    system_clock::now is 2022-02-05 13:52:15
    ```

    `<iomanip>` 头文件包括 put_time()，其工作方式类似于 ostream 的 strftime():

    ```cpp
    std::time_t now_t = system_clock::to_time_t(t);
    cout << "system_clock::now is "
        << std::put_time(std::localtime(&now_t), "%F %T")
        << '\n';
    ```

    put_time() 接受一个指向 C 风格 time_t*值的指针。system_clock::to_time_t 转换 time_point 对象为 time_t。

    这与 format() 示例的输出相同：

    ```shell
    system_clock::now is 2022-02-05 13:52:15
    ```

- 也可以使用 system_clock 为事件计时。首先，需要进行计时。下面是一个计算质数的函数：

    ```cpp
    constexpr uint64_t MAX_PRIME{ 0x1FFFF }
    uint64_t count_primes() {
        constexpr auto is_prime = [](const uint64_t n) {
            for(uint64_t i{ 2 }; i < n / 2; ++i) {
                if(n % i == 0) return false;
            }
            return true;
        };
        uint64_t count{ 0 };
        uint64_t start{ 2 };
        uint64_t end{ MAX_PRIME };
        for(uint64_t i{ start }; i <= end ; ++i) {
            if(is_prime(i)) ++count;
        }
        return count;
    }
    ```

    这个函数对 2 到 0x1FFFF(131,071) 之间的质数进行计数，在大多数现代系统上，这需要几秒钟的时间。

- 现在，编写一个计时器函数来计时 count_primes():

    ```cpp
    seconds timer(uint64_t(*f)()) {
        auto t1{ system_clock::now() };
        uint64_t count{ f() };
        auto t2{ system_clock::now() };
        seconds secs{ t2 - t1 };
        cout << format("there are {} primes in range\n",
            count);
        return secs;
    }
    ```

    这个函数接受一个函数 `f`，并返回 `duration<double>`。这里使用 `system_clock::now()` 来标记调用 `f()` 前后的时间。取两个时间之间的差值，并在 duration 对象中返回。

- 可以在 main() 中使用 timer():

    ```cpp
    int main() {
        auto secs{ timer(count_primes) };
        cout << format("time elapsed: {:.3f} seconds\n",
        secs.count());
        ...
    ```

    这将把 count_primes() 函数传递给 timer()，并以秒为单位存储持续时间对象。

    输出为：

    ```text
    there are 12252 primes in range time elapsed: 3.573
    seconds
    ```

    duration 对象上的 count() 方法返回指定单位的持续时间------本例中为 double，表示持续时间的秒数。

    这是在一个运行 Debian 和 GCC 的 VM 上运行的，具体的时间在不同的系统上会有所不同。

- system_clock 类设计用来提供当前挂钟时间。虽然其频率可能支持计时目的，但不保证单调。换句话说，它可能不能提供一致的计时间隔。

    chrono 库在 steady_clock 中提供了一个更合适的时钟。它具有与 system_clock 相同的接口，但为计时目的提供了更可靠的计时间隔：

    ```cpp
    seconds timer(uint64_t(*f)()) {
        auto t1{ steady_clock::now() };
        uint64_t count{ f() };
        auto t2{ steady_clock::now() };
        seconds secs{ t2 - t1 };
        cout << format("there are {} primes in range\n",
            count);
        return secs;
    }
    ```

    steady_clock 设计用于提供可靠一致的单调，适用于计时事件。它使用一个相对的时间参考，所以不用挂钟时间。system_clock 从固定的时间点 (1970 年 1 月 1 日 00:00
    UTC) 开始测量，而 steady_clock 使用相对时间。

    另一个选项是 high_resolution_clock，在给定系统上提供最短的计时间隔期，但在不同的实现中实现不一致。其可能是 system_clock 或 steady_clock 的别名，可能是单调的，也可能不是。

    high_resolution_clock 不建议通用。

- `timer()` 函数返回 seconds，是 `duration<double>` 的别名：

    ```cpp
    using seconds = duration<double>;
    ```

    duration 类接受一个可选的第二个模板形参，一个 std::ratio 类：

    ```cpp
    template<class Rep, class Period = std::ratio<1>>
    class duration;
    ```

    `<chrono>` 头文件为许多十进制比率提供了方便的类型，包括 milli 和 micro:

    ```cpp
    using milliseconds = duration<double, std::milli>;
    using microseconds = duration<double, std::micro>;
    ```

    若需要其他工具，可以自己准备：

    ```cpp
    using fps24 = duration<unsigned long, std::ratio<1, 24>>;
    ```

    fps24 表示以标准的每秒 24 帧拍摄的电影帧数。比率是 1/24 秒。

    这让我们可以轻松地在不同的持续时间范围之间进行转换：

    ```cpp
    cout << format("time elapsed: {:.3f} sec\n", secs.
    count());
    cout << format("time elapsed: {:.3f} ms\n",
        milliseconds(secs).count());
    cout << format("time elapsed: {:.3e} μs\n",
        microseconds(secs).count());
    cout << format("time elapsed: {} frames at 24 fps\n",
        floor<fps24>(secs).count());
    ```

    输出为：

    ```text
    time elapsed: 3.573 sec time elapsed: 3573.077 ms time
    elapsed: 3.573e+06 μs time elapsed: 85 frames at 24 fps
    ```

    因为 fps24 别名使用 unsigned
    long，而不是 double，所以需要进行类型转换。floor 函数通过丢弃小数部分来实现这一点。Round() 和 ceil() 在此上下文中也可用。

- 方便起见，chrono 库提供了标准持续时间比的 format() 特化：

    ```cpp
    cout << format("time elapsed: {:.3}\n", secs);
    cout << format("time elapsed: {:.3}\n",
    milliseconds(secs));
    cout << format("time elapsed: {:.3}\n",
    microseconds(secs));
    ```

    输出为：

    ```text
    time elapsed: 3.573s time elapsed: 3573.077ms time
    elapsed: 3573076.564μs
    ```

    这些结果在不同的实现上有所不同。

### How it works

chrono 库有两个主要部分，时钟类和间隔类。

**时钟类**
时钟类包括：

- system_clock——提供挂钟时间。
- steady_clock——为时间测量提供有保证的单调计时间隔。
- high_resolution_clock——提供最短的可用计时间隔周期。某些系统上，其可能是 system_clock 或 steady_clock 的别名。

我们使用 system_clock 显示当前时间和日期，用 steady_clock 来测量间隔。

每个时钟类都有一个 now() 方法，该方法返回 time_point，表示时钟的当前值。now() 是一个静态成员函数，所以可以不实例化对象：

```cpp
auto t1{ steady_clock::now() };
```

**std::duration 类**
duration 类用于保存时间间隔——即两个 time_point 对象之间的差值。它通常由 time_point 对象的减法 (-) 操作符构造。

```cpp
duration<double> secs{ t2 - t1 };
```

time_point 减去操作符作为 duration 的构造函数：

```cpp
template<class C, class D1, class D2>
constexpr duration<D1,D2>
operator-( const time_point<C,D1>& pt_lhs,
    const time_point<C,D2>& pt_rhs );
```

duration 类有用于类型表示的模板参数和一个 ratio 对象：

```cpp
template<class Rep, class Period = std::ratio<1>>
class duration;
```

周期模板参数默认为 1:1，即秒。

标准库为 10 次方提供了从 atto(1/1,000,000,000,000,000,000) 到 exa(1,000,000,000,000,000,000/1) 的比率别名 (例如 micro 和 milli)。我们可以创建标准的持续时间，就像示例中那样：

```cpp
using milliseconds = duration<double, std::milli>;
using microseconds = duration<double, std::micro>;
```

count() 方法给出了 Rep 类型中的持续时间：

```cpp
constexpr Rep count() const;
```

这使得我们可以方便地访问持续时间，并用于显示或其他目的：

```cpp
cout << format("duration: {}\n", secs.count());
```

## 8.6.对可变元组使用折叠表达式

tuple 类本质上是一个更复杂、不方便的结构体。tuple 的接口很麻烦，类模板参数推导和结构化绑定可以使这个过程变得简单。

对于大多数应用程序，我倾向于在使用 tuple 之前使用 struct，但有一个例外:tuple 的一个真正优势是，可以在可变的上下文中与折叠表达式一起使用。

### 折叠表达式

折叠表达式是 C++17 的一个新特性，设计目的是为了更容易地展开可变参数包。在折叠表达式之前，展开参数包需要一个递归函数：

```cpp
template<typename T>
void f(T final) {
    cout << final << '\n';
}
template<typename T, typename... Args>
void f(T first, Args... args) {
    cout << first;
    f(args...);
}
int main() {
    f("hello", ' ', 47, ' ', "world");
}
```

输出为：

```text
hello 47 world
```

使用折叠表达式后，这就会简单许多了：

```cpp
template<typename... Args>
void f(Args... args) {
    (cout << ... << args);
    cout << '\n';
}
```

输出为：

```text
hello 47 world
```

折叠表达式有四种类型：

- 一元右折叠：(args op ...)

- 一元左折叠：(... op args)

- 二元右折叠：(args op ... op init)

- 二元左折叠：(init op ... op args)

上面例子中的表达式是一个二进制左折叠：

```cpp
(cout << ... << args);
```

可扩展为：

```cpp
cout << "hello" << ' ' << 47 << ' ' << "world";
```

折叠表达式对于很多目的来说都是非常方便的，来看看如何在 tuple 中使用。

### How to do it

这个示例中，我们将创建一个模板函数，该函数对具有不同数量和类型元素的 tuple 进行操作：

- 这示例的核心是一个函数，其接受一个未知大小和类型的 tuple，并使用 format() 打印每个元素：

    ```cpp
    template<typename... T>
    constexpr void print_t(const tuple<T...>& tup) {
        auto lpt =
        [&tup] <size_t... I>
        (std::index_sequence<I...>)
        constexpr {
            (..., ( cout <<
                format((I? ", {}" : "{}"),
                    get<I>(tup))
            ));
            cout << '\n';
        };
        lpt(std::make_index_sequence<sizeof...(T)>());
    }
    ```

    这个函数的核心在 lambda 表达式中，使用 index_sequence 对象生成索引值的参数包。然后，使用折叠表达式对每个下标值调用 ·。模板化的 lambda 需要编译器支持 C++20。

    可以使用一个单独的函数来代替 lambda，但我更喜欢将它保持在一个作用域中。

- 现在可以在 main() 中使用各种 tuple:

    ```cpp
    int main() {
        tuple lables{ "ID", "Name", "Scale" };
        tuple employee{ 123456, "John Doe", 3.7 };
        tuple nums{ 1, 7, "forty-two", 47, 73L, -111.11 };

        print_t(lables);
        print_t(employee);
        print_t(nums);
    }
    ```

    输出为：

    ```text
    ID, Name, Scale 123456, John Doe, 3.7 1, 7, forty-two,
    47, 73, -111.11
    ```

### How it works

使用 `tuple` 的挑战在于它的限制性接口。可以使用 `std::tie()`、结构化绑定或 `std::get<>` 函数检索元素。若不知道 `tuple` 中元素的数量和类型，这些技术都没啥用。

可以使用 `index_sequence` 类来解决这个限制。`index_sequence` 是一个 `integer_sequence` 的特化，它提供了一个 `size_t` 的参数包，可以用它来索引 tuple。我们使用 `make_index_sequence` 调用 `lambda` 函数在 `lambda` 中设置一个参数包：

```cpp
lpt(std::make_index_sequence<sizeof...(T)>());
```

模板化的 `lambda` 是用 `get()` 函数 `size_t` 索引的参数包构造的：

```cpp
[&tup] <size_t... I> (std::index_sequence<I...>) constexpr {
    ...
};
```

get() 函数将索引值作为模板形参，这里可以使用一元左折叠表达式调用 `get<I>()`:

```cpp
(..., ( cout << format("{} ", std::get<I>(tup))));
```

折叠表达式接受函数参数包中的每个元素，并应用逗号操作符。逗号的右边有一个 `format()` 函数，输出元组的每个元素。

这使得推断 `tuple` 中元素的数量成为可能，这使得它可以在可变的上下文中使用。记住，与一般的模板函数一样，编译器将为每个 `tuple` 形参组合生成该函数的特化版本。

### There's more

也可以将这种技术用于其他任务。例如，这里有一个函数，它返回大小未知的元组中所有 int 值的和：

```cpp
template<typename... T>
constexpr int sum_t(const tuple<T...>& tup) {
    int accum{};
    auto lpt =
    [&tup, &accum] <size_t... I>
        (std::index_sequence<I...>)
    constexpr {
        (..., (
            accum += get<I>(tup)
        ));
    };
    lpt(std::make_index_sequence<sizeof...(T)>());
    return accum;
}
```

可以用几个不同数量 int 值的元组对象调用这个函数：

```cpp
tuple ti1{ 1, 2, 3, 4, 5 };
tuple ti2{ 9, 10, 11, 12, 13, 14, 15 };
tuple ti3{ 47, 73, 42 };
auto sum1{ sum_t(ti1) };
auto sum2{ sum_t(ti2) };
auto sum3{ sum_t(ti3) };
cout << format("sum of ti1: {}\n", sum1);
cout << format("sum of ti2: {}\n", sum2);
cout << format("sum of ti3: {}\n", sum3);
```

输出为：

```text
sum of ti1: 15 sum of ti2: 84 sum of ti3: 162
```

## 8.7.std::unique_ptr 管理已分配的内存

智能指针是管理已分配堆内存的优秀工具。

堆内存由 C 函数 malloc() 和 free() 在最低层进行管理。malloc() 从堆中分配一块内存，free() 将内存返还给堆。这些函数不执行初始化，也不调用构造函数或析构函数。若未能通过调用 free() 将已分配的内存返回给堆，则该行为是未定义的，通常会导致内存泄漏和安全漏洞。

C++提供了 new 和 delete 操作符来分配和释放堆内存，用以取代 malloc() 和 free()。new 和 delete 操作符调用对象构造函数和析构函数，但仍然不管理内存。若使用 new 分配内存，而未能使用 delete 释放它，还是会泄漏内存。

C++14 中引入的智能指针遵循资源获取即初始化 (Resource Acquisition Is
Initialization,
RAII) 习惯用法，当为一个对象分配内存时，将调用该对象的构造函数。当调用对象的析构函数时，内存会自动返回到堆中。

例如，当使用 `make_unique()` 创建一个新的智能指针时：

```cpp
{ // beginning of scope
    auto p = make_unique<Thing>(); // memory alloc’d,
    // ctor called
    process_thing(p); // p is unique_ptr<Thing>
} // end of scope, dtor called, memory freed
```

`make_unique()` 为 `Thing` 对象分配内存，调用 Thing 默认构造函数，构造一个 `unique_ptr<Thing>` 对象，并返回 unique_ptr。当 p 超出作用域时，调用 Thing 析构函数，内存自动返回到堆中。

除了内存管理之外，智能指针的工作原理非常类似于基本指针：

```cpp
auto x = *p; // *p derefs the pointer, returns Thing object
auto y = p->thname; // p-> derefs the pointer, returns member
```

unique_ptr 是一个智能指针，只允许一个指针实例。它可以移动，但不能复制。来仔细了解一下，如何使用 unique_ptr。

### How to do it

在这个示例中，用一个演示类检查 std::unique_ptr，当使用构造函数和析构函数时输出：

- 首先，创建一个简单的演示类：

    ```cpp
    struct Thing {
        string_view thname{ "unk" };
        Thing() {
            cout << format("default ctor: {}\n", thname);
        }
        Thing(const string_view& n) : thname(n) {
            cout << format("param ctor: {}\n", thname);
        }
        ~Thing() {
            cout << format("dtor: {}\n", thname);
        }
    };
    ```

    该类有一个默认构造函数、一个参数化构造函数和一个析构函数。每一个都有打印语句，告诉我们调用了什么。

- 当只构造一个 unique_ptr 时，不会分配内存或构造一个托管对象：

    ```cpp
    int main() {
        unique_ptr<Thing> p1;
        cout << "end of main()\n";
    }
    ```

    输出为：

    ```text
    end of main()
    ```

- 当使用 `new` 操作符时，会分配内存并构造一个 `Thing` 对象：

    ```cpp
    int main() {
        unique_ptr<Thing> p1{ new Thing };
        cout << "end of main()\n";
    }
    ```

    输出为：

    ```text
    default ctor: unk end of main() dtor: unk
    ```

    `new` 操作符通过调用默认构造函数构造 `Thing` 对象。`unique_ptr<Thing>` 析构函数在智能指针到达其作用域的末尾时，调用 `Thing` 析构函数。

    `Thing` 默认构造函数不初始化 `thname` 字符串，会保留其默认值"unk"。

- 也可以使用 make_unique():

    ```cpp
    int main() {
        auto p1 = make_unique<Thing>();
        cout << "end of main()\n";
    }
    ```

    输出为：

    ```text
    default ctor: unk end of main() dtor: unk
    ```

    make_unique() 工厂函数负责内存分配并返回 unique_ptr 对象，这是构造 unique_ptr 的推荐方法。

- 传递给 make_unique() 的参数都将用于构造目标对象：

    ```cpp
    int main() {
        auto p1 = make_unique<Thing>("Thing 1") };
        cout << "end of main()\n";
    }
    ```

    输出为：

    ```text
    param ctor: Thing 1 end of main() dtor: Thing 1
    ```

    参数化构造函数将值赋给 thname，因此 Thing 对象现在是"Thing 1"。

- 创建一个函数，其有一个 `unique_ptr<Thing>` 参数：

    ```cpp
    void process_thing(unique_ptr<Thing> p) {
        if(p) cout << format("processing: {}\n",
            p->thname);
        else cout << "invalid pointer\n";
    }
    ```

    若尝试传递一个 unique_ptr 给这个函数，会得到一个编译器错误：

    ```cpp
    process_thing(p1);
    ```

    编译器错误为：

    ```shell
    error: use of deleted function...
    ```

    这是因为函数调用试图复制 unique_ptr 对象，但删除了 unique_ptr 复制构造函数以防止复制。解决方案是让函数接受一个 const&引用参数：

    ```cpp
    void process_thing(const unique_ptr<Thing>& p) {
        if(p) cout << format("processing: {}\n",
            p->thname);
        else cout << "invalid pointer\n";
    }
    ```

    输出为：

    ```text
    param ctor: Thing 1 processing: Thing 1 end of main()
    dtor: Thing 1
    ```

- 可以用一个临时对象调用 process_thing()，其会在函数作用域的末尾立即销毁：

    ```cpp
    int main() {
        auto p1{ make_unique<Thing>("Thing 1") };
        process_thing(p1);
        process_thing(make_unique<Thing>("Thing 2"));
        cout << "end of main()\n";
    }
    ```

    输出为：

    ```text
    param ctor: Thing 1 processing: Thing 1 param ctor:
    Thing 2 processing: Thing 2 dtor: Thing 2 end of main() dtor: Thing
    1
    ```

### How it works

智能指针只是一个对象，在拥有和管理另一个对象的资源时，可以提供指针接口。

unique_ptr 类由其删除的复制构造函数和复制赋值操作符来区分，这可以防止智能指针的复制。

不能复制 unique_ptr:

```cpp
auto p2 = p1;
```

编译器错误：

```shell
error: use of deleted function...
```

但可以移动 unique_ptr:

```cpp
auto p2 = std::move(p1);
process_thing(p1);
process_thing(p2);
```

移动后，p1 无效，p2 为"Thing 1"。

输出为：

```text
invalid pointer processing: Thing 1 end of main() dtor:
Thing 1
```

unique_ptr 接口有一个重置指针的方法：

```cpp
p1.reset(); // pointer is now invalid
process_thing(p1);
```

输出为：

```text
dtor: Thing 1 invalid pointer
```

reset() 方法也可以将管理对象替换为另一个相同类型的对象：

```cpp
p1.reset(new Thing("Thing 3"));
process_thing(p1);
```

输出为：

```text
param ctor: Thing 3 dtor: Thing 1 processing: Thing 3
```

## 8.8.std::shared_ptr 的共享对象

shared_ptr 类是一个智能指针，拥有自己的托管对象，并维护一个使用计数器来跟踪副本。此示例探索了 shared_ptr 的使用方式，以在共享指针副本的同时管理内存。

``` tcolorbox
有关智能指针的更多详细信息，请参阅本章前面关于使用 std::unique_ptr 管理已分配内存的介绍。
```

### How to do it

在这个示例中，用一个演示类检查 std::shared_ptr，当调用它的构造函数和析构函数时进行打印输出：

- 首先，创建一个简单的演示类：

    ```cpp
    struct Thing {
        string_view thname{ "unk" };
        Thing() {
            cout << format("default ctor: {}\n", thname);
        }
        Thing(const string_view& n) : thname(n) {
            cout << format("param ctor: {}\n", thname);
        }
        ~Thing() {
            cout << format("dtor: {}\n", thname);
        }
    };
    ```

    该类有一个默认构造函数、一个参数化构造函数和一个析构函数。每一个都有打印语句，显示调用了哪些函数。

- shared_ptr 类的工作原理与其他智能指针非常相似，也可以用 new 操作符或 make_shared() 函数来构造：

    ```cpp
    int main() {
        shared_ptr<Thing> p1{ new Thing("Thing 1") };
        auto p2 = make_shared<Thing>("Thing 2");
        cout << "end of main()\n";
    }
    ```

    输出为：

    ```text
    param ctor: Thing 1 param ctor: Thing 2 end of main()
    dtor: Thing 2 dtor: Thing 1
    ```

    推荐使用 make_shared() 函数，它会管理构造过程，并且不太容易出错。

    与其他智能指针一样，当指针超出作用域时，托管对象将销毁，其内存将返回到堆中。

- 下面是一个检查 shared_ptr 对象的使用计数的函数：

    ```cpp
    void check_thing_ptr(const shared_ptr<Thing>& p) {
        if(p) cout << format("{} use count: {}\n",
        p->thname, p.use_count());
        else cout << "invalid pointer\n";
    }
    ```

    thname 是 Thing 类的成员，因此可以通过带有 p->成员解引用操作符的指针访问它。use_count() 函数是 shared_ptr 类的成员，因此，可以使用 p.object 成员操作符访问它。

    让我们使用指针来对其进行调用：

    ```cpp
    check_thing_ptr(p1);
    check_thing_ptr(p2);
    ```

    输出为：

    ```text
    Thing 1 use count: 1 Thing 2 use count: 1
    ```

- 当复制指针时，使用计数会增加，但不会构造新的对象：

    ```cpp
    cout << "make 4 copies of p1:\n";
    auto pa = p1;
    auto pb = p1;
    auto pc = p1;
    auto pd = p1;
    check_thing_ptr(p1);
    ```

    输出为：

    ```text
    make 4 copies of p1: Thing 1 use count: 5
    ```

- 当我们检查其他副本时，会得到相同的结果：

    ```cpp
    check_thing_ptr(pa);
    check_thing_ptr(pb);
    check_thing_ptr(pc);
    check_thing_ptr(pd);
    ```

    输出为：

    ```text
    Thing 1 use count: 5 Thing 1 use count: 5 Thing 1 use
    count: 5 Thing 1 use count: 5
    ```

    每个指针都会报告相同的使用计数。

- 当副本超出作用域时，将进行销毁，并使计数递减：

    ```cpp
    { // new scope
        cout << "make 4 copies of p1:\n";
        auto pa = p1;
        auto pb = p1;
        auto pc = p1;
        auto pd = p1;
        check_thing_ptr(p1);
    } // end of scope
    check_thing_ptr(p1);
    ```

    输出为：

    ```text
    make 4 copies of p1: Thing 1 use count: 5 Thing 1 use
    count: 1
    ```

- 销毁副本将减少使用计数，但不会销毁管理对象。当最终副本超出作用域且使用计数为零时，对象将销毁：

    ```cpp
    {
        cout << "make 4 copies of p1:\n";
        auto pa = p1;
        auto pb = p1;
        auto pc = p1;
        auto pd = p1;
        check_thing_ptr(p1);
        pb.reset();
        p1.reset();
        check_thing_ptr(pd);
    } // end of scope
    ```

    输出为：

    ```text
    make 4 copies of p1: Thing 1 use count: 5 Thing 1 use
    count: 3 dtor: Thing 1
    ```

    销毁 pb(一个副本) 和 p1(原始) 会留下三个指针副本 (pa、bc 和 pd)，因此管理对象仍然存在。

    其余三个指针副本将在创建它们的作用域的末尾销毁。然后销毁对象，并将其内存返回到堆中。

### How it works

shared_ptr 类的区别在于它对指向同一个托管对象的多个指针的管理。

shared_ptr 对象的复制构造函数和复制赋值操作符增加一个使用计数器。析构函数将使用计数器减为零，然后销毁托管对象，并将其内存返还给堆。

shared_ptr 类同时管理托管对象和堆分配的控制块。控制块包含使用计数器以及其他管家对象，控制块与管理对象一起在副本之间进行管理和共享。所以原始 shared_ptr 对象将控制权转让给其副本，以便其他 shared_ptr 可以管理对象及其内存。

## 8.9.对共享对象使用弱指针

严格地说，std::weak_ptr 不是一个智能指针。相反，它是一个与 shared_ptr 合作运行的观察者。weak_ptr 本身不保存指针。

某些情况下，shared_ptr 对象可能会创建悬空指针或数据竞争，这可能导致内存泄漏或其他问题。解决方案是使用具有 shared_ptr 的 weak_ptr 对象。

### How to do it

这个示例中，使用 std::shared_ptr 来检查 std::weak_ptr 的使用。创建一个演示类，当调用它的构造函数和析构函数时进行打印。

- 展示将要在 shared_ptr 和 unique_ptr 中创建的类型：

    ```cpp
    struct Thing {
        string_view thname{ "unk" };
        Thing() {
            cout << format("default ctor: {}\n", thname);
        }
        Thing(const string_view& n) : thname(n) {
            cout << format("param ctor: {}\n", thname);
        }
        ~Thing() {
            cout << format("dtor: {}\n", thname);
        }
    };
    ```

    该类有一个默认构造函数、一个参数化构造函数和一个析构函数。每一个都有一个简单的打印语句告诉我们调用了什么。

- 还需要一个函数来检查 weak_ptr 对象：

    ```cpp
    void get_weak_thing(const weak_ptr<Thing>& p) {
        if(auto sp = p.lock()) cout <<
            format("{}: count {}\n", sp->thname,
                p.use_count());
        else cout << "no shared object\n";
    }
    ```

    weak_ptr 本身不作为指针操作，其需要使用 shared_ptr.lock() 函数返回一个 shared_ptr 对象，然后可以使用该对象访问托管对象。

- 因为 `weak_ptr` 需要一个相关的 `shared_ptr`，将通过创建一个 `shared_ptr<Thing>` 对象来启动 `main()`。当创建一个 `weak_ptr` 对象而不分配 `shared_ptr` 时，会对过期 (expired) 标志进行设置：

    ```cpp
    int main() {
        auto thing1 = make_shared<Thing>("Thing 1");
        weak_ptr<Thing> wp1;
        cout << format("expired: {}\n", wp1.expired());
        get_weak_thing(wp1);
    }
    ```

    输出为：

    ```text
    param ctor: Thing 1 expired: true no shared object
    ```

    make_shared() 函数分配内存并构造一个 Thing 对象。

    `weak_ptr<Thing>` 声明构造了一个 `weak_ptr` 对象，但没有分配 `shared_ptr`。因此，当检查过期标志时，其为真，表明并没有相关的 `shared_ptr`。

    因为没有 `shared_ptr` 可用，所以 `get_weak_thing()` 函数不能获得锁。

- 将 `shared_ptr` 分配给 `weak_ptr` 时，可以使用 `weak_ptr` 来访问托管对象：

    ```cpp
    wp1 = thing1;
    get_weak_thing(wp1);
    ```

    输出为：

    ```text
    Thing 1: count 2
    ```

    `get_weak_thing()` 函数现在可以获取锁并访问托管对象。`lock()` 方法返回一个 `shared_ptr`，`use_count()` 反映了现在有第二个 shared_ptr 管理 Thing 对象的情况。

    新 shared_ptr 在 `get_weak_thing()` 作用域的末尾销毁。

- weak_ptr 类有一个构造函数，其接受 shared_ptr 进行一步构造：

    ```cpp
    weak_ptr<Thing> wp2(thing1);
    get_weak_thing(wp2);
    ```

    输出为：

    ```text
    Thing 1: count 2
    ```

    use_count() 再次为 2，之前的 shared_ptr 在其封闭的 get_weak_thing() 作用域结束时销毁。

- 重置 shared_ptr 时，其关联的 weak_ptr 对象将过期：

    ```cpp
    thing1.reset();
    get_weak_thing(wp1);
    get_weak_thing(wp2);
    ```

    输出为：

    ```text
    dtor: Thing 1 no shared object no shared object
    ```

    reset() 后，使用计数为零，管理对象销毁，内存释放。

### How it works

weak_ptr 对象是一个观察者，其对 shared_ptr 对象属于非所有引用。weak_ptr 会观察 shared_ptr，这样就知道托管对象什么时候可用，什么时候不可用。这允许在您不需要知道托管对象是否处于活动状态的情况下，使用 shared_ptr。

weak_ptr 类有一个 use_count() 函数，返回 shared_ptr 的使用计数，若管理对象已删除，则返回 0:

```cpp
long use_count() const noexcept;
```

weak_ptr 还有一个 expired() 函数，会报告托管对象是否已删除：

```cpp
bool expired() const noexcept;
```

lock() 函数是访问 shared_ptr 的首选方法，其检查 expired() 以查看管理对象是否可用。若可用，将返回一个新的 shared_ptr，该 shared_ptr 与管理对象共享所有权。否则，会返回一个空的 shared_ptr。这些会作为一个原子操作完成：

```cpp
std::shared_ptr<T> lock() const noexcept;
```

### There's more

weak_ptr 的一个重要用例是有可能循环引用 shared_ptr 对象。例如，考虑两个相互链接的类的情况 (可能在一个层次结构中):

```cpp
struct circB;
struct circA {
    shared_ptr<circB> p;
    ~circA() { cout << "dtor A\n"; }
};
struct circB {
    shared_ptr<circA> p;
    ~circB() { cout << "dtor B\n"; }
};
```

在析构函数中有 print 语句，因此可以看到对象何时销毁。现在，可以通过 shared_ptr 创建两个相互指向的对象：

```cpp
int main() {
    auto a{ make_shared<circA>() };
    auto b{ make_shared<circB>() };
    a->p = b;
    b->p = a;
    cout << "end of main()\n";
}
```

当运行这个函数时，会发现析构函数从未调用：

```shell
end of main()
```

因为对象维护着相互引用的共享指针，所以使用计数永远不会达到零，并且托管对象永远不会销毁。

可以通过更改其中一个类来使用 weak_ptr 来解决这个问题：

```cpp
struct circB {
    weak_ptr<circA> p;
    ~circB() { cout << "dtor B\n"; }
};
```

main() 中的代码保持不变，我们会得到这样的输出：

```shell
end of main() dtor A dtor B
```

通过将一个 shared_ptr 更改为 weak_ptr，解决了循环引用，并且现在在对象作用域的末尾，可以正确地销毁对象了。

## 8.10.共享管理对象的成员

std::shared_ptr 类提供了一个别名构造函数，来共享由另一个不相关指针管理的指针：

```cpp
shared_ptr( shared_ptr<Y>&& ref, element_type* ptr ) noexcept;
```

这将返回一个别名 shared_ptr 对象，该对象使用 ref 的资源，但返回一个指向 ptr 的指针，use_count 和 deleter 与 ref 共享，但是 get() 返回 ptr。这可以在不共享整个对象的情况下共享托管对象的一个成员，并且在仍然使用该成员时不允许删除对象。

### How to do it

这个示例中，我们创建了一个托管对象并共享该对象的成员：

- 从托管对象的类开始：

    ```cpp
    struct animal {
        string name{};
        string sound{};
        animal(const string& n, const string& a)
        : name{n}, sound{a} {
            cout << format("ctor: {}\n", name);
        }
        ~animal() {
            cout << format("dtor: {}\n", name);
        }
    };
    ```

    该类有两个成员，animal 对象的名称和声音的字符串类型。构造函数和析构函数也有 print 语句。

- 现在，需要函数来创建 animal，但只分享名字和声音：

    ```cpp
    auto make_animal(const string& n, const string& s) {
        auto ap = make_shared<animal>(n, s);
        auto np = shared_ptr<string>(ap, &ap->name);
        auto sp = shared_ptr<string>(ap, &ap->sound);
        return tuple(np, sp);
    }
    ```

    这个函数创建与动物对象 shared_ptr，由名字和声音构造。然后，为名字和声音创建别名 shared_ptr 对象。当返回 name 和 sound 指针时，animal 指针将超出作用域。因为别名指针可以防止使用计数达到零，所以不会删除。

- `main()` 函数中，使用 make_animal() 并检查结果：

    ```cpp
    int main() {
        auto [name, sound] =
            make_animal("Velociraptor", "Grrrr!");
        cout << format("The {} says {}\n", *name, *sound);
        cout << format("Use count: name {}, sound {}\n",
            name.use_count(), sound.use_count());
    }
    ```

    输出为：

    ```text
    ctor: Velociraptor The Velociraptor says Grrrr! Use
    count: name 2, sound 2 dtor: Velociraptor
    ```

    每个别名指针的 use_count 值为 2。当 make_animal() 函数创建别名指针时，其会增加 animal 指针的使用次数。当函数结束时，animal 指针超出作用域，使其使用计数为 2，这反映在别名指针中。别名指针在 main() 的末尾超出了作用域，可以销毁 animal 指针。

### How it works

别名共享指针看起来有点抽象，但它比看起来要简单。

共享指针使用一个控制块来管理资源。一个控制块与一个托管对象相关联，并在共享该对象的指针之间共享。控制块一般包含：

- 指向管理对象的指针

- 删除器

- 分配器

- 拥有托管对象的 shared_ptr 对象的数量 (使用计数)

- 引用管理对象的 weak_ptr 对象的数量

使用别名共享指针的情况下，控制块包括指向别名对象的指针，其他不变。

别名共享指针参与使用计数，就像非别名共享指针一样，防止托管对象在使用计数为零之前销毁。删除器没有改变，所以它会破坏管理对象。

``` tcolorbox
可以使用任何指针来构造别名共享指针。通常，指针指向别名对象中的成员。若别名指针没有引用托管对象的元素，则需要分别管理其构造和销毁。
```

## 8.11.比较随机数引擎

随机库提供了选择的随机数生成器，每个生成器具有不同的策略和属性。本节中，我们检查一个函数，通过创建输出的直方图来比较不同的选项。

### How to do it

这个示例中，比较了 C++随机库提供的不同随机数生成器：

- 从一些常量开始，为随机数生成器提供统一参数：

    ```cpp
    constexpr size_t n_samples{ 1000 };
    constexpr size_t n_partitions{ 10 };
    constexpr size_t n_max{ 50 };
    ```

    n_samples 是要检查的样本数量，n_partitions 是用来显示样本的分区数量，n_max 是直方图中条形图的最大值 (由于四舍五入的关系，这个值会有所变化)。

    这些数字合理地显示了引擎之间的差异。增加样本与分区的比例往往会使曲线变得平滑，并模糊引擎之间的差异。

- 这是一个收集随机数样本并显示直方图的函数：

    ```cpp
    template <typename RNG>
    void histogram(const string_view& rng_name) {
        auto p_ratio = (double)RNG::max() / n_partitions;
        RNG rng{}; // construct the engine object

        // collect the samples
        vector<size_t> v(n_partitions);
        for(size_t i{}; i < n_samples; ++i) {
            ++v[rng() / p_ratio];
        }

        // display the histogram
        auto max_el = std::max_element(v.begin(),
            v.end());
        auto v_ratio = *max_el / n_max;
        if(v_ratio < 1) v_ratio = 1;
        cout << format("engine: {}\n", rng_name);
        for(size_t i{}; i < n_partitions; ++i) {
            cout << format("{:02}:{:*<{}}\n",
                i + 1, ' ', v[i] / v_ratio);
        }
        cout << '\n';
    }
    ```

    简而言之，这个函数将收集的样本的直方图存储在一个 vector 中。然后，在控制台上以星号的形式显示直方图。

- 在 main() 使用 histogram()，如下所示：

    ```cpp
    int main() {
        histogram<std::random_device>("random_device");
        histogram<std::default_random_engine>
            ("default_random_engine");
        histogram<std::minstd_rand0>("minstd_rand0");
        histogram<std::minstd_rand>("minstd_rand");
        histogram<std::mt19937>("mt19937");
        histogram<std::mt19937_64>("mt19937_64");
        histogram<std::ranlux24_base>("ranlux24_base");
        histogram<std::ranlux48_base>("ranlux48_base");
        histogram<std::ranlux24>("ranlux24");
        histogram<std::ranlux48>("ranlux48");
        histogram<std::knuth_b>("knuth_b");
    }
    ```

    输出为：

    ``` center
    ![image](content/chapter8/images/1.png){width="60%"}\
    图 8.1 前两个随机数引擎输出的截图
    ```

    截图显示了前两个随机数引擎的直方图。

    若将 n_samples 的值提高到 100,000，会发现引擎之间的差异变得更难辨别：

    ``` center
    ![image](content/chapter8/images/2.png){width="60%"}\
    图 8.2 100,000 个样本的输出截图
    ```

### How it works

每个随机数引擎都有一个函子接口，返回序列中的下一个随机数：

```cpp
result_type operator()();
```

函子会返回一个随机值，平均分布在 min() 和 max() 值之间。所有的随机数引擎都有这个接口。

histogram() 函数可以通过在模板中使用随机数引擎类，来利用这种一致性：

```cpp
template <typename RNG>
```

(RNG 是随机数生成器 (Random Number
Generator) 的缩写。标准库文档将这些类称为引擎，就我们的目的而言，这与 RNG 同义。)

我们用 RNG 类实例化一个对象，并在 vector 中创建一个直方图：

```cpp
RNG rng{};
vector<size_t> v(n_partitions);
for(size_t i{}; i < n_samples; ++i) {
    ++v[rng() / p_ratio];
}
```

使用这种方式，可以很容易地比较各种随机数引擎的结果。

### There's more

库中的每个随机数引擎都有不同的方法和特征。当多次运行直方图时，会注意到大多数引擎在每次运行时都具有相同的分布，因为它们是确定的------每次生成相同的数字序列。std::random_device 在大多数系统上是不确定的。若需要更多的变化，可以使用它为其他引擎生成随机种子。使用当前日期和时间为 RNG 种子的情况也很常见。

std::default_random_engine 对于多数情况来说都是一个合适的选择。

## 8.12.比较随机数分布发生器

C++标准库提供了一系列随机数分布生成器，每个生成器都有自己的属性。本节中，我们检查一个函数，通过创建输出的直方图来比较不同的选项。

### How to do it

与随机数引擎一样，分布生成器也有一些公共的接口元素。与随机数引擎不同，分布生成器有各种属性可以设置。可以创建一个模板函数来打印各种分布的直方图，但各种分布生成器的初始化差异很大：

- 先从一些常数开始：

    ```cpp
    constexpr size_t n_samples{ 10 * 1000 };
    constexpr size_t n_max{ 50 };
    ```

    n_samples 常数是为每个直方图生成的样本数量------在本例中为 10,000。

    生成直方图时，n_max 常数作为除数。

- 直方图函数以分布生成器作为参数，并打印该分布算法的直方图：

    ```cpp
    void dist_histogram(auto distro,
            const string_view& dist_name) {
        std::default_random_engine rng{};
        map<long, size_t> m;

        // create the histogram map
        for(size_t i{}; i < n_samples; ++i)
            ++m[(long)distro(rng)];

        // print the histogram
        auto max_elm_it = max_element(m.begin(), m.end(),
            [](const auto& a, const auto& b)
            { return a.second < b.second; }
            );
        size_t max_elm = max_elm_it->second;
        size_t max_div = std::max(max_elm / n_max,
            size_t(1));
        cout << format("{}:\n", dist_name);
        for (const auto [randval, count] : m) {
            if (count < max_elm / n_max) continue;
            cout << format("{:3}:{:*<{}}\n",
                randval, ' ', count / max_div);
        }
    }
    ```

    dist_histogram() 函数的作用是：使用 map 来存储直方图。然后，在控制台上以星号的形式显示直方图。

- 在 main() 调用 dist_histogram():

    ```cpp
    int main() {
        dist_histogram(std::uniform_int_distribution<int>
            {0, 9}, uniform_int_distribution");
        dist_histogram(std::normal_distribution<double>
            {0.0, 2.0}, "normal_distribution");
        ...
        }
    ```

    调用 dist_histogram() 函数比调用随机数生成器要复杂得多。每个随机分布类别根据其算法有不同的参数集。

    要获得完整的列表，请参考 GitHub 库中的 distribution.cpp 文件。

    输出为：

    ``` center
    ![image](content/chapter8/images/3.png){width="60%"}\
    图 8.3 随机分布直方图的截图
    ```

    每种分布算法产生非常不同的输出，可以试一下每个随机分布生成器的不同选项。

### How it works

每个分布生成器都有一个返回随机分布中下一个值的函子：

```cpp
result_type operator()( Generator& g );
```

函子以随机数生成器 (RNG) 对象作为参数：

```cpp
std::default_random_engine rng{};
map<long, size_t> m;
for (size_t i{}; i < n_samples; ++i) ++m[(long)distro(rng)];
```

现在，我们在 RNG 中使用 std::default_random_engine。

与 RNG 直方图一样，这是一个有用的工具，可以可视化随机库中可用的各种随机分布算法。可以对每种算法可用的各种参数进行试验。
